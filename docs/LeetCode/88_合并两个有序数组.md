# 🧩 合并两个有序数组（LeetCode 88: Merge Sorted Array）

## 📘 题目描述

给你两个有序整数数组 `nums1` 和 `nums2`，请你将 `nums2` 合并到 `nums1` 中，使 `nums1` 成为一个有序数组。

**注意：**
- 初始时 `nums1` 的长度为 `m + n`，前 `m` 个元素表示有效数字，后 `n` 个元素为 0，用来容纳 `nums2`；
- `nums2` 的长度为 `n`。

**示例：**
```java
输入：
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6], n = 3

输出： [1,2,2,3,5,6]
```

---

## 💡 思路一：从后往前双指针

### ✅ 你的思路
从数组末尾开始合并：  
- 因为 `nums1` 的尾部有多余空间，可以从大到小填充；  
- 用两个指针 `m-1` 和 `n-1`，分别指向两个数组的最后有效元素；  
- 比较二者大小，将较大者放入 `nums1` 的末尾。

这样可以避免数据被覆盖。

### 🔧 代码实现
```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        for (int i = m + n - 1; i >= 0; i--) {
            if (m <= 0) {
                nums1[i] = nums2[n - 1];
                n--;
                continue;
            }
            if (n <= 0) {
                nums1[i] = nums1[m - 1];
                m--;
                return;
            }

            if (nums1[m - 1] >= nums2[n - 1]) {
                nums1[i] = nums1[m - 1];
                m--;
            } else {
                nums1[i] = nums2[n - 1];
                n--;
            }
        }
    }
}
```

### 📊 复杂度分析
| 项目 | 分析 |
|------|------|
| **时间复杂度** | `O(m + n)` — 每个元素被处理一次 |
| **空间复杂度** | `O(1)` — 原地合并，无需额外数组 |

---

## ⚡ 思路二：更简洁的写法（推荐）

### ✅ 逻辑简化版
不使用 `for`，直接使用 `while` 循环，更清晰。

```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int i = m - 1, j = n - 1, k = m + n - 1;
        while (i >= 0 && j >= 0) {
            if (nums1[i] > nums2[j]) {
                nums1[k--] = nums1[i--];
            } else {
                nums1[k--] = nums2[j--];
            }
        }
        // 若 nums2 还有剩余，直接拷贝
        while (j >= 0) {
            nums1[k--] = nums2[j--];
        }
    }
}
```

### 🧠 优化思路
- 不需要再考虑 `i < j` 的复杂情况；
- 处理剩余 `nums2` 即可（因为剩余 `nums1` 已经在正确位置）。

---

## 🧩 模板总结：从后往前合并类问题

```java
int i = m - 1, j = n - 1, k = m + n - 1;
while (i >= 0 && j >= 0) {
    if (nums1[i] > nums2[j]) nums1[k--] = nums1[i--];
    else nums1[k--] = nums2[j--];
}
while (j >= 0) nums1[k--] = nums2[j--];
```

该模板常用于：
- 合并两个有序数组（88）
- 合并区间类问题
- 有序链表合并问题（21）

---

## 🔍 拓展题推荐
| 题目 | 思路 | 难度 |
|------|------|------|
| [LeetCode 21. 合并两个有序链表](https://leetcode.com/problems/merge-two-sorted-lists/) | 双指针 | 🟢 |
| [LeetCode 56. 合并区间](https://leetcode.com/problems/merge-intervals/) | 排序 + 合并 | 🟡 |
| [LeetCode 88. 合并两个有序数组](https://leetcode.com/problems/merge-sorted-array/) | 双指针 | 🟢 |

---

## 🧠 总结
- 从后向前是关键思路，防止数据被覆盖；  
- 你的写法逻辑完整、考虑边界清晰；  
- 推荐进一步简化为 `while` 写法，代码更直观；  
- 此题是**双指针与原地修改结合的经典基础题**。

---

**关键词：**  
`双指针`、`原地修改`、`数组合并`、`排序数组`
